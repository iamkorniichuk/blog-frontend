{
    "how-to-configure-angular-v20-project-for-vercel": {
        "id": "how-to-configure-angular-v20-project-for-vercel",
        "title": "How to Configure Angular V20 Project for Vercel",
        "description": "Complete configuration for your Angular V20 project for Vercel functions that just works.",
        "cover": "./images/angular-vercel-cover.png",
        "coverAlt": "An arrow drawn from an Angular logo into a Vercel logo on white background",
        "content": "## Introduction\n\nDeploying an Angular app to Vercel is wonderfully easy — until you add Server-Side Rendering (SSR).\n\nA static Angular site builds to HTML, CSS, and JavaScript, which Vercel can host effortlessly from the `/dist` folder. But when you switch to SSR with `@angular/ssr`, your app becomes a Node server that renders pages on demand.\nVercel doesn’t just serve static files; it needs to **run** your server entry point as a **function**.\n\nAngular v20 makes this easier than ever, but you still have to tell Vercel where that server function lives and how to handle routing.\n\n## Why a Plain Deployment Isn’t Enough\n\nIf you build your Angular SSR app with:\n\n```bash\nng build && ng run <YOUR-PROJECT-NAME>:serve-ssr\n```\n\nyou’ll get a `dist/<YOUR-PROJECT-NAME>/server/server.mjs` file.\nThat’s the actual Node entry point — the compiled version of your `server.ts`.\n\nIf you just push this folder to Vercel without configuration, it *looks* like it’s working. Vercel will deploy the static files in `dist/<YOUR-PROJECT-NAME>/browser`, and your site will load.\n\nBut under the hood, SSR won’t run — Vercel is only serving static HTML. No server, no prerendering, no dynamic routes.\nThe reason: Vercel doesn’t automatically execute arbitrary `.mjs` files as functions. You must explicitly map your entry point into its **serverless function system**.\n\n## The Proper Configuration\n\nVercel expects functions inside an `api/` directory at the project root.\nEach file there becomes an endpoint, like `/api/index.mjs`, which Vercel executes as a serverless function.\n\nTo bridge Angular’s SSR output with Vercel’s runtime, create this file:\n\n\n```javascript api/index.mjs\nconst { reqHandler } = await import(\"../dist/<YOUR-PROJECT-NAME>/server/server.mjs\");\n\nexport default reqHandler;\n```\n\nReplace `<YOUR-PROJECT-NAME>` with the name of your project folder under `dist/`.\nThe `reqHandler` function is what Angular exposes as the universal request listener — it handles routing, rendering, and response.\n\nThis single file acts as the connection between Vercel’s request pipeline and your Angular SSR app.\n\n## Routing Everything Through the Function\n\nNext, create or update your `vercel.json` configuration file:\n```json vercel.json\n{\n  \"version\": 2,\n  \"name\": \"blog\",\n  \"rewrites\": [\n    {\n      \"source\": \"/(.*)\",\n      \"destination\": \"/api\"\n    }\n  ],\n  \"functions\": {\n    \"api/index.mjs\": {\n      \"includeFiles\": \"dist/<YOUR-PROJECT-NAME>/**\"\n    }\n  }\n}\n```\n\nHere’s what this does:\n\n* The **rewrite rule** tells Vercel that every route (like `/about`, `/blog/post/123`, etc.) should go to `/api`, which runs our server function.\n* The **includeFiles** property ensures all necessary Angular build files (your compiled server, browser assets, templates, etc.) are bundled with the function.\n\nWithout this, Vercel might only package the `api/index.mjs` file — and your SSR app would crash because it can’t find its runtime assets.\n\n## Deployment\n\nOnce your files are in place, deploy as you normally would:\n\n```bash\nvercel --prod\n```\n\nor through GitHub integration — whichever you prefer.\n\nVercel will detect your configuration, package your SSR build as a function, and handle all requests through it.\nAfter a successful deployment, visit your app and check the source: you’ll see **fully rendered HTML** coming from the server, not just the client bundle.\n\n## Summary\n\nDeploying an Angular SSR app to Vercel works perfectly — as long as you point Vercel to the right function.\n\nIt’s a minimal setup — two short files — but it transforms your Angular app from a static build into a full SSR deployment on Vercel’s edge infrastructure.\n\nOnce configured, you can treat Vercel as your Angular app’s zero-maintenance Node host — no servers to run, no ports to open, just instant global rendering.",
        "solution": "Create `api/index.mjs` file in the root folder with the next content:\n```js api/index.mjs\nconst { reqHandler } = await import(\"../dist/<YOUR-PROJECT-NAME>/server/server.mjs\");\n\nexport default reqHandler;\n```\nThen, in `vercel.json` file write this configuration:\n```json vercel.json\n{\n    \"version\": 2,\n    \"name\": \"blog\",\n    \"rewrites\": [\n        {\n            \"source\": \"/(.*)\",\n            \"destination\": \"/api\"\n        }\n    ],\n    \"functions\": {\n        \"api/index.mjs\": {\n            \"includeFiles\": \"dist/<YOUR-PROJECT-NAME>/**\"\n        }\n    }\n}\n```\n**Don't forget** to replace `<YOUR-PROJECT-NAME>` with your actual app name (the folder name under `dist/` when you build).\n\nDeploy to your Vercel with any method you comfortable with.",
        "tags": [
            "Vercel",
            "Angular V20",
            "Node.js",
            "Angular SSR",
            "DevOps"
        ],
        "createdAt": "2025-09-14T22:46:00+02:00"
    },
    "how-to-upscale-images-for-free-online": {
        "id": "how-to-upscale-images-for-free-online",
        "title": "How to Upscale Images for Free Online",
        "description": "Free Online tool to upscale your images without credits, sign up and subscriptions.",
        "cover": "./images/image-upscale-cover.png",
        "coverAlt": "An image of a lake, forest, mountains and blue sky splitted out in half into low quality (before) and high quality (after) parts",
        "content": "## Introduction\n\nSometimes an image just isn’t big enough. Maybe it’s a screenshot that needs to fit a presentation, a texture that looks muddy up close, or an old logo that didn’t survive the march of Retina displays.\n\nThe web is full of “free image upscalers,” but most of them send your files to remote servers, throttle usage, or quietly store your data. What if the browser itself could do the work — no uploads, no limits, no accounts?\n\nThat’s exactly what a browser-native AI upscaler does. Using `UpscalerJS` and the ESRGAN-Thick model family, it can enhance images entirely on your device — directly in JavaScript.\n\n## Why Browser-Side Upscaling Works\n\nModern browsers aren’t just document viewers anymore; they’re computation platforms. With **WebGL** or **WebGPU**, they can run small neural networks fast enough to do image super-resolution in real time.\n\nThe model I use, **ESRGAN-Thick**, belongs to the family of Enhanced Super-Resolution Generative Adversarial Networks. In short, it guesses what extra pixels should look like based on patterns learned from real-world images.\n\nWhen you double or quadruple an image’s resolution, the network fills in plausible details instead of just stretching existing pixels. It’s pattern synthesis, not interpolation.\n\n## Using the Tool\n\nTo try it yourself, go to the [Image Upscale page](/tools/image-upscale).\n\n1. Upload one or more images (there’s no enforced limit).\n2. Choose an upscale factor — **2x**, **3x**, **4x**, or **8x**.\n3. Click **Upscale**.\n\nProcessing happens entirely in your browser. You can even go offline after loading the page; no requests are made to any external API or server.\n\n## What’s Actually Happening\n\nWhen you press the button, the app spins up a **web worker** — a background thread so the UI stays responsive. The worker loads the ESRGAN-Thick model weights and applies them tile by tile over your image.\n\nEach tile is passed through a deep convolutional network, and the results are stitched back together. The heavy math runs on the GPU through TensorFlow.js. It’s slower on integrated graphics but fast enough for single images on most laptops.\n\n## The Trade-Offs\n\nRunning AI locally isn’t magic; it has boundaries.\n\n* **Performance varies** — Large images can take several seconds, or even minutes, on weaker hardware.\n* **Memory use is real** — Upscaling multiplies pixel counts. An 8× upscaling of a 1000×1000 image turns into 64 million pixels. Browsers can handle that, but not endlessly.\n* **Model generalization has limits** — ESRGAN was trained on a mix of photographic content. It works well on natural images, textures, and drawings, but can over-sharpen text or UI screenshots.\n* **File size grows** — Bigger images mean heavier downloads if you serve them back to users, so use upscaling where it makes sense.\n\nStill, for personal projects, prototypes, or in-browser tools, it’s hard to beat the simplicity of “load once, upscale forever.”\n\n## Under the Hood\n\nAll of this runs through **UpscalerJS**, a library that wraps model loading, GPU execution, and output handling. Because it works with web workers, it doesn’t block Angular’s rendering loop — it just reports progress as it goes.\n\nHere’s the key design idea: you move AI inference as close to the user as possible. Instead of sending data to a server farm, you borrow their GPU for a moment.\n\n## Summary\n\nBrowser-side image upscaling won’t replace professional tools that run on specialized hardware. It’s slower, less flexible, and occasionally produces artifacts.\n\nBut it’s private, transparent, and surprisingly capable — a reminder of how much computing power already lives inside the browser.\n\nWith Angular handling the interface and UpscalerJS doing the pixel work, you get a lightweight, self-contained image enhancer that costs nothing to run and respects user privacy.\n\nA good example of how web apps can be both simpler and smarter at the same time.",
        "solution": "Go to [Image Upscale page](/tools/image-upscale), upload your images (unlimited number), choose a desired upscale factor (2x-8x)  and press \"Upscale\" button. **Voilà!**",
        "tags": [
            "Useful Websites",
            "AI",
            "Recommendations"
        ],
        "createdAt": "2025-09-11T18:17:00+02:00"
    },
    "dynamic-sitemap-in-angular-v20": {
        "id": "dynamic-sitemap-in-angular-v20",
        "title": "Dynamic Sitemap in Angular V20",
        "description": "Learn how to create a dynamic sitemap in Angular V20 that will help search engines index your freshly uploaded content.",
        "cover": "./images/dynamic-sitemap-cover.png",
        "coverAlt": "A loading circle on top of a blurred out icon of a sitemap on white background",
        "content": "## Introduction\n\nSearch engines thrive on structure. They’re not artistic explorers — they’re librarians cataloging your digital shelves. To make your Angular app discoverable, you need to hand those librarians a clean, up-to-date **index** of your content. That’s what a **sitemap** does.\n\nAngular v20’s built-in SSR (Server-Side Rendering) capabilities through `@angular/ssr` make it easy to create and serve a **dynamic sitemap** directly from your Node server — no rebuilds, no manual updates, and no pretending HTML is XML.\n\n## Why You Need a Dynamic Sitemap\n\nA sitemap tells Google, Bing, and other crawlers where your pages live, how often they change, and which ones matter most.\nBut if your site’s content is dynamic—blog posts, portfolios, user-generated pages — a static `sitemap.xml` quickly becomes stale.\n\nA dynamic sitemap fixes that by generating URLs at runtime. When a new blog post or route appears, your sitemap updates automatically. No redeploy. No rebuild. Search engines always see the current state of your site.\n\n## Why a Component Page Won’t Work\n\nIt’s tempting to create a `SitemapComponent` and just render XML-looking markup inside it. Unfortunately, Angular components live inside an HTML ecosystem—**they can’t escape Angular’s wrapper**.\n\nWhen you serve a route like `/sitemap` through a component, three problems arise:\n\n1. **Incorrect MIME Type**\n   Angular apps always serve pages as `text/html`. Crawlers expect `application/xml`. Without the right MIME type, Google will ignore your sitemap or throw an “Invalid XML format” warning.\n\n2. **Angular’s DOM Wrapping**\n   Every Angular view sits inside an `<app-root>` or `<app-sitemap>` element. Your XML ends up like this:\n\n   ```html\n   <app-sitemap>\n     <?xml version=\"1.0\"?>\n     <urlset>...</urlset>\n   </app-sitemap>\n   ```\n\n   That’s HTML, not XML. Crawlers don’t like HTML wrapped in XML clothing.\n\n## What server.ts Does\n\nWhen you enable SSR with: `ng add @angular/ssr`.\n\nAngular generates a file called `app/server.ts`. This file is your **server entry point**, powered by Express (a Node.js web framework). It bridges Angular’s rendering engine with the Node environment.\n\nHere’s what it does conceptually:\n\n* **Bootstraps your Angular app on the server:**\n  It imports and runs the server version of your Angular app so it can render HTML before sending it to the browser.\n* **Serves static files:**\n  It delivers your compiled JavaScript, CSS, and images.\n* **Defines API endpoints:**\n  You can extend it—like we’ll do here—to respond to specific routes (e.g., `/sitemap.xml`).\n\nThink of `server.ts` as the backstage manager that decides how to serve your app’s responses, while Angular itself handles the on-stage performance.\n\n## Solution\n\nSitemap's schema expects an XML page with URLs that have next properties: `loc` (required), `lastmod` (optional), `changefreq` (optional), and `priority` (optional but very important). For details, refer to the [Sitemap Official website](https://www.sitemaps.org/protocol.html).\n\nOpen `app/server.ts` and you will find this comment:\n```typescript app/server.ts\n/**\n * Example Express Rest API endpoints can be defined here.\n * Uncomment and define endpoints as necessary.\n *\n * Example:\n * ```typescript\n * app.get('/api/{*splat}', (req, res) => {\n *   // Handle API request\n * });\n * ```\n */\n```\n\nReplace this comment with `app.get('/sitemap.xml', (request, response) => {})` that will define a new `GET` route.\n\n### Defining routes\nInside a lambda function, you can declare your routes, calling external APIs, building a path, etc.\nThe example with calling an API service:\n```typescript app/server.ts\nconst tutorialApi = new TutorialApiService();\n\nconst urls = [\n  { loc: 'https: //example.com', changefreq: 'weekly', priority: 1 },\n  { loc: 'https://example.com/about-us', changefreq: 'yearly', priority: 0.9, lastmod: '2025-01-01' },\n  { loc: 'https://example.com/tools', changefreq: 'monthly', priority: 0.8 },\n  { loc: 'https://example.com/tools/image-upscale', changefreq: 'yearly', priority: 0.7 },\n  { loc: 'https://example.com/tutorials', changefreq: 'weekly', priority: 0.8 },\n];\n\ntutorialApi.readAllIds().then(results => {\n  for (const id of results) {\n    urls.push({ loc: `https://example.com/tutorials/${id}`, changefreq: 'monthly', priority: 0.7 });\n  }\n});\n```\n\n### Building XML page\nNext, we need to build an XML string:\n```typescript app/server.ts\nconst xml = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  ${urls\n    .map(\n      (u) => `\n      <url>\n        <loc>${u.loc}</loc>\n        ${u.lastmod ? `<lastmod>${u.lastmod}</lastmod>` : ''}\n        ${u.changefreq ? `<changefreq>${u.changefreq}</changefreq>` : ''}\n        ${u.priority ? `<priority>${u.priority}</priority>` : ''}\n      </url>`,\n    )\n    .join('')}\n</urlset>\n`.trim();\n```\n\nNext, we need to set a status code, content type header, and send our XML page:\n```typescript app/server.ts\nresponse.header('Content-Type', 'application/xml');\nresponse.status(200).send(xml);\n```\n\n### Whole code example\nThat's all! The whole code looks like this:\n```typescript app/server.ts\napp.get('/sitemap.xml', (request, response) => {\n  const tutorialApi = new TutorialApiService();\n  const urls = [\n    { loc: 'https://example.com', changefreq: 'weekly', priority: 1 },\n    { loc: 'https://example.com/about-us', changefreq: 'yearly', priority: 0.9, lastmod: '2025-01-01' },\n    { loc: 'https://example.com/tools', changefreq: 'monthly', priority: 0.8 },\n    { loc: 'https://example.com/tools/image-upscale', changefreq: 'yearly', priority: 0.7 },\n    { loc: 'https://example.com/tutorials', changefreq: 'weekly', priority: 0.8 },\n  ];\n\n  tutorialApi.readAllIds().then(results => {\n    for (const id of results) {\n      urls.push({ loc: `https://example.com/tutorials/${id}`, changefreq: 'monthly', priority: 0.7 });\n    }\n  });\n\n  const xml = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  ${urls\n      .map(\n        (u) => `\n      <url>\n        <loc>${u.loc}</loc>\n        ${u.lastmod ? `<lastmod>${u.lastmod}</lastmod>` : ''}\n        ${u.changefreq ? `<changefreq>${u.changefreq}</changefreq>` : ''}\n        ${u.priority ? `<priority>${u.priority}</priority>` : ''}\n      </url>`,\n      )\n      .join('')}\n</urlset>\n`.trim();\n\n  response.header('Content-Type', 'application/xml');\n  response.status(200).send(xml);\n});\n```\n\n![Sitemap example](./images/sitemap-example.png)\n\n\n## Verification with Google Search Console\n\nOnce your dynamic sitemap is live, you’ll want to verify and register it with Google. Here’s how:\n\n1. Deploy your app.\n2. Go to [Google Search Console](https://search.google.com/search-console/). Add your website (if not done previously).\n\n3. Verify your ownership (if not done previously).\n\n4. In the “Sitemaps” section, enter the full URL to the website's `sitemap.xml`.\n\n5. Google will process your sitemap and start indexing pages. You can track which URLs are discovered, indexed, or skipped.\n\n![Successful indexing](./images/successful-indexing.png)\n\n\n## Summary\n\n`server.ts` is where your Angular app stops being a purely client-side experience and starts behaving like a proper web server. By defining a `/sitemap.xml` endpoint inside it, you gain fine-grained control over headers, MIME types, and dynamically generated content.\n\nThe result:\n\n* A valid, SEO-friendly XML sitemap.\n* Automatic updates with no redeploys.\n* Full compatibility with Google Search Console and other crawlers.\n\nIn essence, this approach turns your Angular app into a living organism that updates itself—always ready for discovery in the ever-growing ecosystem of the web.",
        "solution": "In `app/server.ts` change this comment: \n```typescript app/server.ts\n/**\n * Example Express Rest API endpoints can be defined here.\n * Uncomment and define endpoints as necessary.\n *\n * Example:\n * ```typescript\n * app.get('/api/{*splat}', (req, res) => {\n *   // Handle API request\n * });\n * ```\n */\n```\n to this:\n```typescript app/server.ts\napp.get('/sitemap.xml', (request, response) => {\n  // Your urls - can be retrieved from API with `async` call and `.then()`\n  const urls = [\n    { loc: 'https://example.com', changefreq: 'weekly', lastmod: '07/10/25', priority: 1 },\n    { loc: 'https://example.com/about', changefreq: 'yearly', priority: 0.9 },\n    { loc: 'https://example.com/blogs', changefreq: 'daily', priority: 0.8 },\n    { loc: 'https://example.com/blogs/1', changefreq: 'yearly', priority: 0.7 },\n  ];\n  const xml = `\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n        ${urls\n      .map(\n        (u) => `\n            <url>\n              <loc>${u.loc}</loc>\n              ${u.lastmod ? `<lastmod>${u.lastmod}</lastmod>` : ''}\n              ${u.changefreq ? `<changefreq>${u.changefreq}</changefreq>` : ''}\n              ${u.priority ? `<priority>${u.priority}</priority>` : ''}\n            </url>`,\n      )\n      .join('')}\n      </urlset>\n    `.trim();\n  response.header('Content-Type', 'application/xml');\n  response.status(200).send(xml);\n});\n```",
        "tags": [
            "Angular",
            "Angular SSR",
            "Node.js",
            "SEO"
        ],
        "createdAt": "2025-09-07T21:24:00+02:00"
    },
    "hide-scrollbar-but-keep-scrolling-behavior-in-css": {
        "id": "hide-scrollbar-but-keep-scrolling-behavior-in-css",
        "title": "Hide Scrollbar but keep Scrolling behavior in CSS",
        "description": "Learn how to hide a scrollbar without removing the scrolling behavior in CSS.",
        "cover": "./images/hide-scrollbar-cover.png",
        "coverAlt": "A crossed out horizontal scroll bar on white background",
        "content": "## Introduction\nIn modern web design, it’s common to create layouts where content scrolls but the scrollbar itself is hidden. This gives a cleaner, more polished look and works especially well for minimalistic designs, image galleries, and card carousels. Using CSS, you can easily **hide the scrollbar but keep scrolling behavior in CSS**, ensuring that users can still navigate content naturally.\n### When to Avoid\nWhile hiding scrollbars can improve the look of your design, there are situations where it can actually harm usability. For example:\n-  **Horizontal Scrolling Without Buttons**\n\tHorizontal scrolling can be unintuitive if no scrollbar or navigation buttons are visible. Many users don’t realize they can scroll sideways using the `Shift` key + mouse wheel. This can lead to important content being overlooked\n- **Long Content Sections**\n\t If a section contains a lot of content and users can’t see a scrollbar, they might assume the content ends where it visually appears. Hiding the scrollbar may make users miss content in long text blocks or lists.\n***\nIn general, hiding scrollbars works best for small, decorative scrollable areas like image galleries, sliders, or cards where scrolling is intuitive and expected. For critical content or horizontal scrolling areas, consider keeping a subtle scrollbar or adding clear navigation cues to maintain usability.\n## Solution\n### HTML Example\nTo start, create a scrollable container in your HTML and give it a class like `no-scrollbar`:\n```html\n<div class=\"no-scrollbar\">\n\t<img src=./image.png/>\n</div>\n```\nInitially, this container will show a scrollbar if the content overflows:\n![Overflow with a scrollbar](./images/overflow-with-scrollbar.png 'Overflow with a scrollbar')\n### CSS styling\nNext, apply the following CSS to hide the scrollbar but retain the scrolling functionality:\n```css\n.no-scrollbar {\n\toverflow: auto;           /* allow overflow */\n\t-ms-overflow-style: none; /* hides in Internet Explorer and old Edge */\n\tscrollbar-width: none;    /* hides in Firefox */\n}\n\n/* hides in Chrome, Safari, new Edge, and Opera */\n.no-scrollbar::-webkit-scrollbar {\n\tdisplay: none;\n}\n```\nWith this CSS applied, the scrollbar disappears, but the content is still scrollable:\n![Overflow without a scrollbar](./images/overflow-without-scrollbar.gif 'Overflow without a scrollbar')\n## Compatibility\n| Browser | Compatible |\n|:--- |:---:|\n| Chrome | ✅ |\n| Edge | ✅ |\n| Firefox | ✅ |\n| Safari | ✅ |\n| Internet Explorer | ✅ |\n| Opera | ✅ |\n\nMost modern browsers fully support this technique. Internet Explorer and older Edge versions use `-ms-overflow-style`. Firefox uses `scrollbar-width`, while Chrome, Safari, new Edge and Opera rely on the `::-webkit-scrollbar` pseudo-element. This ensures that your content scrolls smoothly without showing a scrollbar in almost every browser.",
        "solution": "Add `.no-scrollbar` to your container. Then, add the next code to your CSS:\n```css\n.no-scrollbar {\n\t-ms-overflow-style: none;\n\tscrollbar-width: none;\n}\n\n\n.no-scrollbar::-webkit-scrollbar {\n\tdisplay: none;\n}\n```",
        "tags": [
            "CSS",
            "HTML",
            "Frontend"
        ],
        "createdAt": "2025-09-04T16:40:00+02:00"
    }
}