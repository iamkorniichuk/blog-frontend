{
    "how-to-upscale-images-for-free-online": {
        "id": "how-to-upscale-images-for-free-online",
        "title": "How to Upscale Images for Free Online",
        "description": "Free Online tool to upscale your images without credits, sign up and subscriptions.",
        "cover": "./images/image-upscale-cover.png",
        "content": "## Introduction\n\nSometimes an image just isn’t big enough. Maybe it’s a screenshot that needs to fit a presentation, a texture that looks muddy up close, or an old logo that didn’t survive the march of Retina displays.\n\nThe web is full of “free image upscalers,” but most of them send your files to remote servers, throttle usage, or quietly store your data. What if the browser itself could do the work — no uploads, no limits, no accounts?\n\nThat’s exactly what a browser-native AI upscaler does. Using `UpscalerJS` and the ESRGAN-Thick model family, it can enhance images entirely on your device — directly in JavaScript.\n\n## Why Browser-Side Upscaling Works\n\nModern browsers aren’t just document viewers anymore; they’re computation platforms. With **WebGL** or **WebGPU**, they can run small neural networks fast enough to do image super-resolution in real time.\n\nThe model I use, **ESRGAN-Thick**, belongs to the family of Enhanced Super-Resolution Generative Adversarial Networks. In short, it guesses what extra pixels should look like based on patterns learned from real-world images.\n\nWhen you double or quadruple an image’s resolution, the network fills in plausible details instead of just stretching existing pixels. It’s pattern synthesis, not interpolation.\n\n## Using the Tool\n\nTo try it yourself, go to the [Image Upscale page](/tools/image-upscale).\n\n1. Upload one or more images (there’s no enforced limit).\n2. Choose an upscale factor — **2x**, **3x**, **4x**, or **8x**.\n3. Click **Upscale**.\n\nProcessing happens entirely in your browser. You can even go offline after loading the page; no requests are made to any external API or server.\n\n## What’s Actually Happening\n\nWhen you press the button, the app spins up a **web worker** — a background thread so the UI stays responsive. The worker loads the ESRGAN-Thick model weights and applies them tile by tile over your image.\n\nEach tile is passed through a deep convolutional network, and the results are stitched back together. The heavy math runs on the GPU through TensorFlow.js. It’s slower on integrated graphics but fast enough for single images on most laptops.\n\n## The Trade-Offs\n\nRunning AI locally isn’t magic; it has boundaries.\n\n* **Performance varies** — Large images can take several seconds, or even minutes, on weaker hardware.\n* **Memory use is real** — Upscaling multiplies pixel counts. An 8× upscaling of a 1000×1000 image turns into 64 million pixels. Browsers can handle that, but not endlessly.\n* **Model generalization has limits** — ESRGAN was trained on a mix of photographic content. It works well on natural images, textures, and drawings, but can over-sharpen text or UI screenshots.\n* **File size grows** — Bigger images mean heavier downloads if you serve them back to users, so use upscaling where it makes sense.\n\nStill, for personal projects, prototypes, or in-browser tools, it’s hard to beat the simplicity of “load once, upscale forever.”\n\n## Under the Hood\n\nAll of this runs through **UpscalerJS**, a library that wraps model loading, GPU execution, and output handling. Because it works with web workers, it doesn’t block Angular’s rendering loop — it just reports progress as it goes.\n\nHere’s the key design idea: you move AI inference as close to the user as possible. Instead of sending data to a server farm, you borrow their GPU for a moment.\n\n## Summary\n\nBrowser-side image upscaling won’t replace professional tools that run on specialized hardware. It’s slower, less flexible, and occasionally produces artifacts.\n\nBut it’s private, transparent, and surprisingly capable — a reminder of how much computing power already lives inside the browser.\n\nWith Angular handling the interface and UpscalerJS doing the pixel work, you get a lightweight, self-contained image enhancer that costs nothing to run and respects user privacy.\n\nA good example of how web apps can be both simpler and smarter at the same time.",
        "solution": "Go to [Image Upscale page](/tools/image-upscale), upload your images (unlimited number), choose a desired upscale factor (2x-8x)  and press \"Upscale\" button. **Voilà!**",
        "tags": [
            "Useful Websites",
            "AI",
            "Recommendations"
        ],
        "createdAt": "2025-10-11T18:17:00+02:00"
    },
    "dynamic-sitemap-in-angular-v20": {
        "id": "dynamic-sitemap-in-angular-v20",
        "title": "Dynamic Sitemap in Angular V20",
        "description": "Learn how to create a dynamic sitemap in Angular V20 that will help search engines index your freshly uploaded content.",
        "cover": "./images/dynamic-sitemap-cover.png",
        "content": "## Introduction\n\nSearch engines thrive on structure. They’re not artistic explorers — they’re librarians cataloging your digital shelves. To make your Angular app discoverable, you need to hand those librarians a clean, up-to-date **index** of your content. That’s what a **sitemap** does.\n\nAngular v20’s built-in SSR (Server-Side Rendering) capabilities through `@angular/ssr` make it easy to create and serve a **dynamic sitemap** directly from your Node server — no rebuilds, no manual updates, and no pretending HTML is XML.\n\n## Why You Need a Dynamic Sitemap\n\nA sitemap tells Google, Bing, and other crawlers where your pages live, how often they change, and which ones matter most.\nBut if your site’s content is dynamic—blog posts, portfolios, user-generated pages — a static `sitemap.xml` quickly becomes stale.\n\nA dynamic sitemap fixes that by generating URLs at runtime. When a new blog post or route appears, your sitemap updates automatically. No redeploy. No rebuild. Search engines always see the current state of your site.\n\n## Why a Component Page Won’t Work\n\nIt’s tempting to create a `SitemapComponent` and just render XML-looking markup inside it. Unfortunately, Angular components live inside an HTML ecosystem—**they can’t escape Angular’s wrapper**.\n\nWhen you serve a route like `/sitemap` through a component, three problems arise:\n\n1. **Incorrect MIME Type**\n   Angular apps always serve pages as `text/html`. Crawlers expect `application/xml`. Without the right MIME type, Google will ignore your sitemap or throw an “Invalid XML format” warning.\n\n2. **Angular’s DOM Wrapping**\n   Every Angular view sits inside an `<app-root>` or `<app-sitemap>` element. Your XML ends up like this:\n\n   ```html\n   <app-sitemap>\n     <?xml version=\"1.0\"?>\n     <urlset>...</urlset>\n   </app-sitemap>\n   ```\n\n   That’s HTML, not XML. Crawlers don’t like HTML wrapped in XML clothing.\n\n## What server.ts Does\n\nWhen you enable SSR with: `ng add @angular/ssr`.\n\nAngular generates a file called `app/server.ts`. This file is your **server entry point**, powered by Express (a Node.js web framework). It bridges Angular’s rendering engine with the Node environment.\n\nHere’s what it does conceptually:\n\n* **Bootstraps your Angular app on the server:**\n  It imports and runs the server version of your Angular app so it can render HTML before sending it to the browser.\n* **Serves static files:**\n  It delivers your compiled JavaScript, CSS, and images.\n* **Defines API endpoints:**\n  You can extend it—like we’ll do here—to respond to specific routes (e.g., `/sitemap.xml`).\n\nThink of `server.ts` as the backstage manager that decides how to serve your app’s responses, while Angular itself handles the on-stage performance.\n\n## Solution\n\nSitemap's schema expects an XML page with URLs that have next properties: `loc` (required), `lastmod` (optional), `changefreq` (optional), and `priority` (optional but very important). For details, refer to the [Sitemap Official website](https://www.sitemaps.org/protocol.html).\n\nOpen `app/server.ts` and you will find this comment:\n```ts app/server.ts\n/**\n * Example Express Rest API endpoints can be defined here.\n * Uncomment and define endpoints as necessary.\n *\n * Example:\n * ```ts\n * app.get('/api/{*splat}', (req, res) => {\n *   // Handle API request\n * });\n * ```\n */\n```\n\nReplace this comment with `app.get('/sitemap.xml', (request, response) => {})` that will define a new `GET` route.\n\n### Defining routes\nInside a lambda function, you can declare your routes, calling external APIs, building a path, etc.\nThe example with calling an API service:\n```ts app/server.ts\nconst tutorialApi = new TutorialApiService();\n\nconst urls = [\n  { loc: 'https://example.com', changefreq: 'weekly', priority: 1 },\n  { loc: 'https://example.com/about-us', changefreq: 'yearly', priority: 0.9, lastmod: '2025-01-01' },\n  { loc: 'https://example.com/tools', changefreq: 'monthly', priority: 0.8 },\n  { loc: 'https://example.com/tools/image-upscale', changefreq: 'yearly', priority: 0.7 },\n  { loc: 'https://example.com/tutorials', changefreq: 'weekly', priority: 0.8 },\n];\n\ntutorialApi.readAllIds().then(results => {\n  for (const id of results) {\n    urls.push({ loc: `https://example.com/tutorials/${id}`, changefreq: 'monthly', priority: 0.7 });\n  }\n});\n```\n\n### Building XML page\nNext, we need to build an XML string:\n```ts app/server.ts\nconst xml = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  ${urls\n    .map(\n      (u) => `\n      <url>\n        <loc>${u.loc}</loc>\n        ${u.lastmod ? `<lastmod>${u.lastmod}</lastmod>` : ''}\n        ${u.changefreq ? `<changefreq>${u.changefreq}</changefreq>` : ''}\n        ${u.priority ? `<priority>${u.priority}</priority>` : ''}\n      </url>`,\n    )\n    .join('')}\n</urlset>\n`.trim();\n```\n\nNext, we need to set a status code, content type header, and send our XML page:\n```ts app/server.ts\nresponse.header('Content-Type', 'application/xml');\nresponse.status(200).send(xml);\n```\n\n### Whole code example\nThat's all! The whole code looks like this:\n```ts app/server.ts\napp.get('/sitemap.xml', (request, response) => {\n  const tutorialApi = new TutorialApiService();\n  const urls = [\n    { loc: 'https://example.com', changefreq: 'weekly', priority: 1 },\n    { loc: 'https://example.com/about-us', changefreq: 'yearly', priority: 0.9, lastmod: '2025-01-01' },\n    { loc: 'https://example.com/tools', changefreq: 'monthly', priority: 0.8 },\n    { loc: 'https://example.com/tools/image-upscale', changefreq: 'yearly', priority: 0.7 },\n    { loc: 'https://example.com/tutorials', changefreq: 'weekly', priority: 0.8 },\n  ];\n\n  tutorialApi.readAllIds().then(results => {\n    for (const id of results) {\n      urls.push({ loc: `https://example.com/tutorials/${id}`, changefreq: 'monthly', priority: 0.7 });\n    }\n  });\n\n  const xml = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  ${urls\n      .map(\n        (u) => `\n      <url>\n        <loc>${u.loc}</loc>\n        ${u.lastmod ? `<lastmod>${u.lastmod}</lastmod>` : ''}\n        ${u.changefreq ? `<changefreq>${u.changefreq}</changefreq>` : ''}\n        ${u.priority ? `<priority>${u.priority}</priority>` : ''}\n      </url>`,\n      )\n      .join('')}\n</urlset>\n`.trim();\n\n  response.header('Content-Type', 'application/xml');\n  response.status(200).send(xml);\n});\n```\n\n![Sitemap example](./images/sitemap-example.png)\n\n\n## Verification with Google Search Console\n\nOnce your dynamic sitemap is live, you’ll want to verify and register it with Google. Here’s how:\n\n1. Deploy your app.\n2. Go to [Google Search Console](https://search.google.com/search-console/). Add your website (if not done previously).\n\n3. Verify your ownership (if not done previously).\n\n4. In the “Sitemaps” section, enter the full URL to the website's `sitemap.xml`.\n\n5. Google will process your sitemap and start indexing pages. You can track which URLs are discovered, indexed, or skipped.\n\n![Successful indexing](./images/successful-indexing.png)\n\n\n## Summary\n\n`server.ts` is where your Angular app stops being a purely client-side experience and starts behaving like a proper web server. By defining a `/sitemap.xml` endpoint inside it, you gain fine-grained control over headers, MIME types, and dynamically generated content.\n\nThe result:\n\n* A valid, SEO-friendly XML sitemap.\n* Automatic updates with no redeploys.\n* Full compatibility with Google Search Console and other crawlers.\n\nIn essence, this approach turns your Angular app into a living organism that updates itself—always ready for discovery in the ever-growing ecosystem of the web.",
        "solution": "In `app/server.ts` change this comment: \n```ts app/server.ts\n/**\n * Example Express Rest API endpoints can be defined here.\n * Uncomment and define endpoints as necessary.\n *\n * Example:\n * ```ts\n * app.get('/api/{*splat}', (req, res) => {\n *   // Handle API request\n * });\n * ```\n */\n```\n to this:\n```ts app/server.ts\napp.get('/sitemap.xml', (request, response) => {\n  // Your urls - can be retrieved from API with `async` call and `.then()`\n  const urls = [\n    { loc: 'https://example.com', changefreq: 'weekly', lastmod: '07/10/25', priority: 1 },\n    { loc: 'https://example.com/about', changefreq: 'yearly', priority: 0.9 },\n    { loc: 'https://example.com/blogs', changefreq: 'daily', priority: 0.8 },\n    { loc: 'https://example.com/blogs/1', changefreq: 'yearly', priority: 0.7 },\n  ];\n  const xml = `\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n        ${urls\n      .map(\n        (u) => `\n            <url>\n              <loc>${u.loc}</loc>\n              ${u.lastmod ? `<lastmod>${u.lastmod}</lastmod>` : ''}\n              ${u.changefreq ? `<changefreq>${u.changefreq}</changefreq>` : ''}\n              ${u.priority ? `<priority>${u.priority}</priority>` : ''}\n            </url>`,\n      )\n      .join('')}\n      </urlset>\n    `.trim();\n  response.header('Content-Type', 'application/xml');\n  response.status(200).send(xml);\n});\n```",
        "tags": [
            "Angular",
            "Angular SSR",
            "Node.js",
            "SEO"
        ],
        "createdAt": "2025-10-07T21:24:00+02:00"
    },
    "hide-scrollbar-but-keep-scrolling-behavior-in-css": {
        "id": "hide-scrollbar-but-keep-scrolling-behavior-in-css",
        "title": "Hide Scrollbar but keep Scrolling behavior in CSS",
        "description": "Learn how to hide a scrollbar without removing the scrolling behavior in CSS.",
        "cover": "./images/hide-scrollbar-cover.png",
        "content": "## Introduction\nIn modern web design, it’s common to create layouts where content scrolls but the scrollbar itself is hidden. This gives a cleaner, more polished look and works especially well for minimalistic designs, image galleries, and card carousels. Using CSS, you can easily **hide the scrollbar but keep scrolling behavior in CSS**, ensuring that users can still navigate content naturally.\n### When to Avoid\nWhile hiding scrollbars can improve the look of your design, there are situations where it can actually harm usability. For example:\n-  **Horizontal Scrolling Without Buttons**\n\tHorizontal scrolling can be unintuitive if no scrollbar or navigation buttons are visible. Many users don’t realize they can scroll sideways using the `Shift` key + mouse wheel. This can lead to important content being overlooked\n- **Long Content Sections**\n\t If a section contains a lot of content and users can’t see a scrollbar, they might assume the content ends where it visually appears. Hiding the scrollbar may make users miss content in long text blocks or lists.\n***\nIn general, hiding scrollbars works best for small, decorative scrollable areas like image galleries, sliders, or cards where scrolling is intuitive and expected. For critical content or horizontal scrolling areas, consider keeping a subtle scrollbar or adding clear navigation cues to maintain usability.\n## Solution\n### HTML Example\nTo start, create a scrollable container in your HTML and give it a class like `no-scrollbar`:\n```html\n<div class=\"no-scrollbar\">\n\t<img src=./image.png/>\n</div>\n```\nInitially, this container will show a scrollbar if the content overflows:\n![Overflow with a scrollbar](./images/overflow-with-scrollbar.png 'Overflow with a scrollbar')\n### CSS styling\nNext, apply the following CSS to hide the scrollbar but retain the scrolling functionality:\n```css\n.no-scrollbar {\n\toverflow: auto;           /* allow overflow */\n\t-ms-overflow-style: none; /* hides in Internet Explorer and old Edge */\n\tscrollbar-width: none;    /* hides in Firefox */\n}\n\n/* hides in Chrome, Safari, new Edge, and Opera */\n.no-scrollbar::-webkit-scrollbar {\n\tdisplay: none;\n}\n```\nWith this CSS applied, the scrollbar disappears, but the content is still scrollable:\n![Overflow without a scrollbar](./images/overflow-without-scrollbar.gif 'Overflow without a scrollbar')\n## Compatibility\n| Browser | Compatible |\n|:--- |:---:|\n| Chrome | ✅ |\n| Edge | ✅ |\n| Firefox | ✅ |\n| Safari | ✅ |\n| Internet Explorer | ✅ |\n| Opera | ✅ |\n\nMost modern browsers fully support this technique. Internet Explorer and older Edge versions use `-ms-overflow-style`. Firefox uses `scrollbar-width`, while Chrome, Safari, new Edge and Opera rely on the `::-webkit-scrollbar` pseudo-element. This ensures that your content scrolls smoothly without showing a scrollbar in almost every browser.",
        "solution": "Add `.no-scrollbar` to your container. Then, add the next code to your CSS:\n```css\n.no-scrollbar {\n\t-ms-overflow-style: none;\n\tscrollbar-width: none;\n}\n\n\n.no-scrollbar::-webkit-scrollbar {\n\tdisplay: none;\n}\n```",
        "tags": [
            "CSS",
            "HTML",
            "Frontend"
        ],
        "createdAt": "2025-10-04T16:40:00+02:00"
    }
}